package io.techery.janet;

import com.google.common.reflect.TypeToken;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeSpec;

import java.util.ArrayList;
import java.util.List;

import javax.annotation.processing.Filer;
import javax.lang.model.element.Element;
import javax.lang.model.element.Modifier;

import io.techery.janet.async.SyncPredicate;
import io.techery.janet.async.annotations.AsyncMessage;
import io.techery.janet.body.ActionBody;
import io.techery.janet.body.BytesArrayBody;
import io.techery.janet.compiler.utils.Generator;
import io.techery.janet.converter.Converter;

public class AsyncWrappersGenerator extends Generator<AsyncActionClass> {

    protected AsyncWrappersGenerator(Filer filer) {
        super(filer);
    }

    @Override public void generate(ArrayList<AsyncActionClass> actionClasses) {
        for (AsyncActionClass actionClass : actionClasses) {
            generate(actionClass);
        }
    }

    private void generate(AsyncActionClass actionClass) {
        //create header
        TypeSpec.Builder classBuilder = TypeSpec.classBuilder(actionClass.getWrapperName())
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                .addJavadoc("Janet compile time, autogenerated class")
                .superclass(ParameterizedTypeName.get(ClassName.get(AsyncActionWrapper.class), actionClass.getTypeName()));

        createConstructor(classBuilder, actionClass);

        classBuilder.addMethod(createIsBytesMessageMethod(actionClass))
                .addMethod(createGetEventMethod(actionClass))
                .addMethod(createGetMessageMethod(actionClass))
                .addMethod(createGetResponseEventMethod(actionClass))
                .addMethod(createFillResponseMethod(actionClass))
                .addMethod(createFillMessageMethod(actionClass))
                .addMethod(createGetResponseTimeoutMethod(actionClass));


        saveClass(actionClass.getPackageName(), classBuilder.build());
    }

    private static TypeSpec.Builder createConstructor(TypeSpec.Builder builder, AsyncActionClass actionClass) {
        MethodSpec.Builder constructorBuilder = MethodSpec.constructorBuilder()
                .addModifiers(Modifier.PUBLIC)
                .addParameter(ParameterizedTypeName.get(ClassName.get(ActionHolder.class), actionClass.getTypeName()), "holder")
                .addStatement("super(holder)");
        if (actionClass.getResponseInfo() != null) {
            builder.addField(SyncPredicate.class, "syncPredicate", Modifier.PRIVATE, Modifier.FINAL);
            constructorBuilder.addStatement("this.syncPredicate = new $T()", actionClass.getResponseInfo().syncPredicateElement);
        }
        builder.addMethod(constructorBuilder.build());
        return builder;
    }

    private static MethodSpec createIsBytesMessageMethod(AsyncActionClass actionClass) {
        return MethodSpec.methodBuilder("isBytesMessage")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .returns(boolean.class)
                .addStatement("return $L", actionClass.isBytesMessage())
                .build();
    }

    private static MethodSpec createGetEventMethod(AsyncActionClass actionClass) {
        return MethodSpec.methodBuilder("getEvent")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .returns(String.class)
                .addStatement("return $S", actionClass.getEvent())
                .build();
    }

    private static MethodSpec createGetMessageMethod(AsyncActionClass actionClass) {
        MethodSpec.Builder builder = MethodSpec.methodBuilder("getMessage")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .addParameter(Converter.class, "converter")
                .returns(ActionBody.class);
        List<Element> fields = actionClass.getAnnotatedElements(AsyncMessage.class);
        if (!fields.isEmpty()) {
            Element field = fields.get(0);
            if (actionClass.isBytesMessage()) {
                builder.addStatement("return action.$L", field);
            } else {
                builder.addStatement("return converter.toBody(action.$L)", field);
            }
        } else {
            builder.addStatement("return null");
        }
        return builder.build();
    }

    private static MethodSpec createGetResponseEventMethod(AsyncActionClass actionClass) {
        String event = null;
        if (actionClass.getResponseInfo() != null) {
            event = actionClass.getResponseInfo().responseEvent;
        }
        return MethodSpec.methodBuilder("getResponseEvent")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .returns(String.class)
                .addStatement("return $S", event)
                .build();
    }


    private static MethodSpec createFillResponseMethod(AsyncActionClass actionClass) {
        MethodSpec.Builder builder = MethodSpec.methodBuilder("fillResponse")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .addParameter(Object.class, "responseAction")
                .returns(boolean.class);
        if (actionClass.getResponseInfo() != null) {
            builder.beginControlFlow("if(syncPredicate.isResponse(this.action, responseAction))");
            builder.addStatement("action.$L = ($L)responseAction", actionClass.getResponseInfo().responseField, actionClass
                    .getResponseInfo().responseField.asType());
            builder.addStatement("return true");
            builder.endControlFlow();
        } else {
            builder.addStatement("//do nothing");
        }
        builder.addStatement("return false");
        return builder.build();
    }

    private static MethodSpec createFillMessageMethod(AsyncActionClass actionClass) {
        Element messageField = actionClass.getMessageField();
        MethodSpec.Builder builder = MethodSpec.methodBuilder("fillMessage")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .addParameter(BytesArrayBody.class, "body")
                .addParameter(Converter.class, "converter");
        builder.beginControlFlow("if(body == null)");
        builder.addStatement("action.$L = null", messageField);
        builder.addStatement("return");
        builder.endControlFlow();
        if (actionClass.isBytesMessage()) {
            builder.addStatement("action.$L = ($T) body", messageField, messageField.asType());
        } else {
            builder.addStatement("action.$L =  ($T) converter.fromBody(body, new $T<$T>(){}.getType())", messageField, messageField
                    .asType(), TypeToken.class, messageField.asType());
        }
        return builder.build();
    }

    private static MethodSpec createGetResponseTimeoutMethod(AsyncActionClass actionClass) {
        MethodSpec.Builder builder = MethodSpec.methodBuilder("getResponseTimeout")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .returns(long.class);
        if (actionClass.getResponseInfo() != null && actionClass.getResponseInfo().responseTimeout > 0) {
            builder.addStatement("return $Ll", actionClass.getResponseInfo().responseTimeout);
        } else {
            builder.addStatement("return super.getResponseTimeout()");
        }
        return builder.build();
    }


}
